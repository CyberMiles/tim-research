= Bancor

You are free to share and adapt this work under the https://creativecommons.org/licenses/by-sa/4.0/[Attribution-ShareAlike 4.0 International terms]

image::license.png[]

== Blockchain infrastructure used in this documentation

This iteration of documentation has been performed on the CyberMiles testnet.

CyberMiles is a blockchain network which is backwards compatible with Ethereum, and therefore, the existing https://github.com/bancorprotocol/contracts[Bancor protocol] code is able to be deployed on the CyberMiles network natively. This provides a fantastic opportunity to deploy and test the Bancor software using a very fast and powerful blockchain. If more information is required, the CyberMiles team have provided certain examples of superior performance and functionality over Ethereum using https://www.cybermiles.io/technical-benchmark/[technical benchmarking].

The CyberMiles testnet can be installed on an Ubuntu 16.04 LTS instance, in just minutes, using https://github.com/CyberMiles/travis/blob/develop/README.md[this bash script]. CyberMiles testnet tokens are available from the http://travis-faucet.cybermiles.io/[Faucet]. 

https://github.com/CyberMiles/tim-research/blob/master/bancor/deployment_example.asciidoc[This deployment example link], provides detailed instructions and syntax. It demonstrates how the Bancor smart contracts, themselves, have been deployed on the CyberMiles testnet.

Continuing on from the above work, the rest of the document, which you are reading now, is aimed at interacting with each of the already deployed Bancor smart contracts, on the CyberMiles testnet. The aim of this document is to demonstrate how Bancor smart contract functions are called i.e. what arguments the Bancor smart contract functions require, as well as what values the Bancor smart contract functions return, to the calling code and so forth.

Just as an aside, https://github.com/CyberMiles/tim-research/blob/master/bancor/restore_deployment_example.js[this script] is an example of how you would re-initialize the Bancor smart contract instance variables in the CyberMiles testnet console, in the event that you detached and then re-attached from the testnet via the "travis attach http://localhost:8545" command.

== Bancor smart contracts
The following documentation list all of the major Bancor smart contracts and their functions, and in addition demonstrates the calling of the smart contract functions in accordance with the https://github.com/CyberMiles/tim-research/blob/master/bancor/deployment_example.asciidoc[deployment example] running on the CyberMiles testnet.

=== Smart Token
Smart Tokens are the heart of the Bancor Protocol [2]. The https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/token/SmartToken.sol[Smart Token contract] inherits from the https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/token/interfaces/ISmartToken.sol[ISmartToken], https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/utility/Owned.sol[Owned], https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/token/ERC20Token.sol[ERC20Token] and https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/utility/TokenHolder.sol[TokenHolder] contracts. All Smart Tokens are ERC20 compatible.

The functions of the Smart Token contract are as follows

**name**

This is just the default getter which returns the name of the Smart Token which was passed into the constructor during initialization of the smart contract.

Takes no arguments

Returns a string

```
deployedSmartTokenContract.name({from:accountA});
```
```
> deployedSmartTokenContract.name({from:accountA});

"New Token"
```

**totalSupply**

This function returns the total supply. This value should be zero by default as there is no way to issue token supply in the contstructor. Issuing token supply must be done with this contract's **issue** function, which is listed below.

Takes no arguments

Returns a uint256

```
deployedSmartTokenContract.totalSupply({from:accountA});
```
```
> deployedSmartTokenContract.totalSupply({from:accountA});

0
```

**decimals**

This is just the default getter which returns the amount of decimal places of the Smart Token which was passed into the constructor during initialization of the smart contract.

Takes no arguments

Returns a uint8

```
deployedSmartTokenContract.decimals({from:accountA});
```
```
> deployedSmartTokenContract.decimals({from:accountA});

18
```

**version**

This returns the value of the public string **version** which is hard-coded into the source code of this smart contract.
Takes no arguments

Returns a string

```
deployedSmartTokenContract.version({from:accountA});
```
```
> deployedSmartTokenContract.version({from:accountA});

"0.3"
```

**standard**

This returns the value of the public string **standard** which is hard-coded into the source of the ERC20Token.sol of which this smart contract inherits from.

Takes no arguments

Returns a string

```
deployedSmartTokenContract.standard({from:accountA});
```
```
> deployedSmartTokenContract.standard({from:accountA});

"Token 0.1"
```

**newOwner**

This is the address of a new owner who has been offered the opportunity to accept ownership of the smart contract. The current owner of the smart contract is the one and only address which can offer this opportunity to the proposed newOwner as we will demonstrate below. The default address value for this variable is 0. It can be set over and over by the current contract owner but is returned to 0 after a new owner accepts via the **acceptOwnership** function, which we also demonstrate below.

Takes no arguments

Returns a address

```
deployedSmartTokenContract.newOwner({from:accountA});
```
```
> deployedSmartTokenContract.newOwner({from:accountA});

"0x0000000000000000000000000000000000000000"
```
**transferOwnership**

This function allows transferring the contract ownership a newly proposed owner. In order for ownership of the contract to be achieved the newly proposed owner still needs to accept via the acceptOwnership function as shown below. This function can only be called by the current contract owner.

Takes 1 arguments

Argument name: _newOwner

Argument type: address

Returns nothing

```
deployedSmartTokenContract.transferOwnership(_newOwner address,  {from:accountA});
```
In the following example we propose that ownership is transferred from the current owner to a new address.
```
//The current owner is accountA
> deployedSmartTokenContract.owner({from:accountA});
"0xbc7a8577c52ad0ec7e0e5df55018fbbd1cec2209"
```
```
//We now propose that accountB become the new owner
> accountB = cmt.accounts[1]
"0x194a20ea8a03564234a5a7fd4108d69a65587abf"
```
```
> deployedSmartTokenContract.transferOwnership(accountB, {from:accountA});
"0xc569261316b88278cb9050ef93f7562568d27964dc7f13b5946d3d91a5f8c9ef"
```
```
//We can see now that the newOwner has changed from the default value of 0 to accountB's address
> deployedSmartTokenContract.newOwner({from:accountA});
"0x194a20ea8a03564234a5a7fd4108d69a65587abf"
```

**acceptOwnership**

This function allows a proposed new owner (who is proposed by the current owner via the transferOwnership function in the Owner.sol) to accept the ownership proposal and therefore have their address stored as the, one and only, address in the **owner** variable of the Owner.sol contract which this contract inherits from. The proposal period is initiated when the original owner sets the **newOwner** variable of the Owner.sol. If the proposed new owner accepts, then the **owner** variable is set to the proposed new owner's calling address and the **newOwner** variable is set back to 0x0000000000000000000000000000000000000000, in preparation for the next proposed new owner.

Takes no arguments

Returns nothing

```
//Unlock accountB so that it can transact on the network
> personal.unlockAccount(accountB , "asdf", 600, function(error, result){if(!error){console.log(result)}else{console.log(error)}});

true
```
```
//Accept ownership
> deployedSmartTokenContract.acceptOwnership({from:accountB});

"0xd07e8e83c535a44b0b64dee815cbb21b3d7be0a409338077bc91ce9211ec4c20"
```
```
//Confirmed by anyone on the network who queries
> deployedSmartTokenContract.owner({from:accountA});

"0x194a20ea8a03564234a5a7fd4108d69a65587abf"
```
```
//Confirm that the newOwner has reverted to the default value of 0
> deployedSmartTokenContract.newOwner({from:accountA});

"0x0000000000000000000000000000000000000000"
```
**owner**

Reveals the owner of the smart contract.

Takes no arguments

Returns a address

```
deployedSmartTokenContract.owner({from:accountA});
```
```
> deployedSmartTokenContract.owner({from:accountA});

"0xbc7a8577c52ad0ec7e0e5df55018fbbd1cec2209"
```

**symbol**

This is just the default getter which returns the symbol of the Smart Token which was passed into the constructor during initialization of the smart contract.

Takes no arguments

Returns a string

```
deployedSmartTokenContract.symbol({from:accountA});
```
```
> deployedSmartTokenContract.symbol({from:accountA});

"NEW"
```
**transfersEnabled**

The **transfersEnabled** variable is a public boolean which is initialized to true when the contract is deployed. The following syntax is just querying the public getter which is generated by the compiler.

Takes no arguments

Returns a bool

```
deployedSmartTokenContract.transfersEnabled({from:accountA});
```
```
> deployedSmartTokenContract.transfersEnabled({from:accountA});

true
```
**disableTransfers**

Passing in a boolean of true will disable transfers to and from addresses. Passing in a boolean of false will allow addresses to transfer value to and from each other. The contract owner is the only one that can enable and disable transfers.

Takes 1 arguments

Argument name: _disable

Argument type: bool

Returns nothing
```
deployedSmartTokenContract.disableTransfers(_disable bool, {from:accountA});
```
```
//Check the status of transfers
> deployedSmartTokenContract.transfersEnabled({from:accountA});
true
```
```
//Disable transfers
> deployedSmartTokenContract.disableTransfers(true,  {from:accountA});

"0x3683da63a6c5e8ed595ef168a7a6b9e6529950a5f61976a9fa788fae038a6923"
```
```
//Confirm the status of transfers is in fact disables
> deployedSmartTokenContract.transfersEnabled({from:accountA});

false
```
```
//Re-enable transfers
> deployedSmartTokenContract.disableTransfers(false,  {from:accountA});

"0xd15f9e2c406e59981d43019b7377611df063c02d1800c5c7fc167917a9c33da0"
```
```
//Confirm
> deployedSmartTokenContract.transfersEnabled({from:accountA});

true
```

**issue**

Takes 2 arguments

Argument name: _to

Argument type: address

Argument name: _amount

Argument type: uint256

Returns nothing

```
deployedSmartTokenContract.issue(_to address, _amount uint256,  {from:accountA});
```
```
//Issue new supply
> deployedSmartTokenContract.issue(accountB, 100,  {from:accountA});

"0x3f2d67df5b9e483f92197f6c1e8bb3e7a20270774cfb941a5a6d2ef931d08388"
```
```
//Check supply
> deployedSmartTokenContract.totalSupply()

100
```
**destroy**

As the opposite of the **issue** function, the **destroy** function removes/burns tokens from the system.

Takes 2 arguments

Argument name: _from

Argument type: address

Argument name: _amount

Argument type: uint256

Returns nothing

```
deployedSmartTokenContract.destroy(_from address, _amount uint256,  {from:accountA});
```

```
//accountA (owner of the smart contract) can issue tokens to accountB
> deployedSmartTokenContract.issue(accountB, 100000000000000000000,  {from:accountA});

"0xb3a47ea849737f80d4ae0ffe567adf8be9fab50feda4e58fba78e66ad51c124d"
```

```
//Check supply
> deployedSmartTokenContract.totalSupply()

100000000000000000000
```

```
//Destroy supply
> deployedSmartTokenContract.destroy(accountB, 100000000000000000000,  {from:accountA});

"0x30ae1f113f41a8a454d0c7de99e44cb6e26838567aa9eba017df40b7c1637ac7"
```

```
//Confirm supply
> deployedSmartTokenContract.totalSupply()

0
```

**approve**

The approve function is inherited from the ERC20Token smart contract. The approve function allows another account/contract to spend some tokens on your behalf.

Approve has to be called twice in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value.

Takes 2 arguments

Argument name: _spender

Argument type: address

Argument name: _value

Argument type: uint256

Returns a bool

```
deployedSmartTokenContract.approve(_spender address, _value uint256,  {from:accountA});
```

Let's try an example of the approve functionality.
```
//Initialize 3 accounts as variables accounts A,B and C
> accountA = cmt.accounts[2]
"0xbc7a8577c52ad0ec7e0e5df55018fbbd1cec2209"
> accountB = cmt.accounts[1]
"0x194a20ea8a03564234a5a7fd4108d69a65587abf"
> accountC = cmt.accounts[0]
"0xd1cf5a620fdae055d4dfb58ed420a5e89bc56858"
```

```
//Issue 100 to accountB
> deployedSmartTokenContract.issue(accountB, 100,  {from:accountA});

"0xaf442c48c80c2092e5b965a1b1205f97a200f988cd3e8854f374bae671fde0bf"
```

```
//Issue 100 to accountC also
deployedSmartTokenContract.issue(accountC, 100,  {from:accountA});
```

```
//Check the total supply
> deployedSmartTokenContract.totalSupply()
200
```

```
> deployedSmartTokenContract.balanceOf(accountA,  {from:accountA});
0
> deployedSmartTokenContract.balanceOf(accountB,  {from:accountB});
100
> deployedSmartTokenContract.balanceOf(accountC,  {from:accountC});
100
```

```
//Now accountC attempts to spend AccountB's tokens by sending them to accountA
> deployedSmartTokenContract.transferFrom(accountB, accountA, 50,  {from:accountC});
```

```
//However, this does not work and the balances remain the same
> deployedSmartTokenContract.balanceOf(accountA,  {from:accountA});
0
> deployedSmartTokenContract.balanceOf(accountB,  {from:accountB});
100
> deployedSmartTokenContract.balanceOf(accountC,  {from:accountC});
100
```
```
//If accountB now approves accountC to spend a value of 50 like this
deployedSmartTokenContract.approve(accountC, 50,  {from:accountB});
```
This transaction 
```
deployedSmartTokenContract.transferFrom(accountB, accountA, 50,  {from:accountC});
```
Will now succeed, as reflected by the balances below
```
> deployedSmartTokenContract.balanceOf(accountA,  {from:accountA});
50
> deployedSmartTokenContract.balanceOf(accountB,  {from:accountB});
50
> deployedSmartTokenContract.balanceOf(accountC,  {from:accountC});
100
```

**transferFrom**

Takes 3 arguments

Argument name: _from

Argument type: address

Argument name: _to

Argument type: address

Argument name: _value

Argument type: uint256

Returns a bool

```
deployedSmartTokenContract.transferFrom(_from address, _to address, _value uint256,  {from:accountA});
```

This function relies heavily on https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/utility/Utils.sol#L55[the assertion] in the safeSub function of the Utils.sol file. Specifically, that the **allowance** mapping instance between **_from** argument and **msg.sender** https://solidity.readthedocs.io/en/v0.4.25/miscellaneous.html#global-variables[global variable] has a value which is greater than or equal to the **_value** argument.

**withdrawTokens**

Takes 3 arguments

Argument name: _token

Argument type: address

Argument name: _to

Argument type: address

Argument name: _amount

Argument type: uint256

Returns nothing

```
deployedSmartTokenContract.withdrawTokens(_token address, _to address, _amount uint256,  {from:accountA});
```
**balanceOf**

Takes 1 arguments

Argument name: 

Argument type: address

Returns a uint256

```
deployedSmartTokenContract.balanceOf( address,  {from:accountA});
```



**transfer**

Takes 2 arguments

Argument name: _to

Argument type: address

Argument name: _value

Argument type: uint256

Returns a bool

```
deployedSmartTokenContract.transfer(_to address, _value uint256,  {from:accountA});
```
**allowance**

Takes 2 arguments

Argument type: address

Argument type: address

Returns a uint256
```
deployedSmartTokenContract.allowance( address,  address,  {from:accountA});
```



= References

https://storage.googleapis.com/website-bancor/2018/04/01ba8253-bancor_protocol_whitepaper_en.pdf
https://www.researchgate.net/publication/327231140_Blockchain_Technology_-_Frequently_Asked_Questions
