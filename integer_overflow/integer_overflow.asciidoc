= Integer Overflow

Disclaimer: This information is based on my personal understanding of integer overflows in code. This document offers no advice nor opinions. This document has only been produced to exercise my personal understanding; it serves as a place to jot down my notes to prompt my thinking.

== Testing multiplication of numbers
A Solidity Smart Contract code for multiplication might look something like this.

[source, bash]
----
pragma solidity ^0.4.23;

/*
        Integer Overflow Testing v0.1
*/

contract IntegerOverflowTesting{
        string public version = "0.1";

        /**
        @dev    This function tests integer multiplication by allowing the caller to pass in any two uint256 integers
        @param  _a is a single uint256 integer value which is passed in by the function caller
        @param  _b is a single uint256 integer value which is passed in by the function caller
        @return This function returns a single uint256 integer value
        */
        function multiply(uint256 _a, uint256 _b) public pure returns(uint256 _c){
                _c = _a * _b;
                return _c;
        }
}
----

If I have two positive numbers 2 and 2 and I multiply them together I get 4 
[source, bash]
----
> deployedSmartTokenContract.multiply(2, 2)
4
----

=== Working with zeros

If any or both of the numbers passed in are zero then the answer will be zero
[source, bash]
----
> deployedSmartTokenContract.multiply(0, 1)
0
> deployedSmartTokenContract.multiply(1, 0)
0
> deployedSmartTokenContract.multiply(0, 0)
0
----

=== Working with ones

Aside from when a zero is presented (as one of the inputs), if one of the inputs is "one" then the output should simply be the value of the other number which is passed in.
[source, bash]
----
> deployedSmartTokenContract.multiply(1, 1)
1
> deployedSmartTokenContract.multiply(1, 2)
2
> deployedSmartTokenContract.multiply(1, 123456789)
123456789
----

=== Pushing the limits

The most that a uint256 variable should accept as input is 2²⁵⁶ -1. 
This number can be represented as a whole number like this
[source, bash]
----
57896044618658097711785492504343953926634992332820282019728792003956564819968
----
Or in hexadecimal form like this
[source, bash]
----
0x8000000000000000000000000000000000000000000000000000000000000000
----




