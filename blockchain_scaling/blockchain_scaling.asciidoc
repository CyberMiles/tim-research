[Blockchain Scaling]
[[Plasma]]

Lightning and Plasma are in the realm of State Channels whereby off-chain messages/transactions between exclusive parties (literally taking a load off the main chain) have an overall effect on the main chain.

== Plasma: Blockchains within blockchains

Plasma is a design pattern which allows you to create your own scalable blockchains (for example allowing blockchains to exist within blockchains) whilst still enjoying the advantages of the security (via the consensus mechanism) which is provided by the main chain. Put simply Ethereum's Plasma implementation allows Ethereum to lend the proven security of its main chain to separate 3rd-party chains.

If you think about this topology you will realise that it provides exponential scaling for blockchains. The best real world example which comes to mind is population growth. For example great grandparent, grandparents, parents can have many children. Only the validity of the child blockchains are stored on the parent chain, negating the need to store all of the gritty details of every transaction on the main chain.

Whilst costly, interactions with the main chain are only necessary when evidence of a dispute is provided. This evidence comes in the form of a proof. But who creates these proofs? How does anyone find out whether an invalid transaction is being performed. This on-chain/off-chain model is analogous to how https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf[TrueBit] works. TrueBit allows untrusted parties (called solvers) on the Ethereum blockchain to solve computational tasks and in turn collect rewards. Of course on the flip side, anyone at all can challenge the outcome of a solver's computational task. Incentives and consequences keep the solvers honest. These sorts of models run under the assumption that all parties involved wish to maximize thier own profit. As a general rule, with accountability and penalties in place, most transactions will simply be performed in a valid manner. This reduces the need to store every tiny transaction and transfer of value, on the main chain, all of the time. 

== Bloom Filters
Bloom filters provide certainty in relation to proof of non-inclusion. 

== Merkle Tries
Merkle tries provide certainty in relation to proof of inclusion.

== Sparse Merkle Trie - a more efficient and simpler alternative Ethereum's Merkle Patricia Trie

A new data structure, known as the https://eprint.iacr.org/2016/683.pdf[Efficient Sparse Merkle Trie will assist in blockchain scaling. Also languages which are simpler and safer than Solidity will be good candidates for writing and testing this new data type and in addition exclusion and inclusion proofs, which support scaling solutions. For example Vyper's pythonic syntax already provides a head start to developers who are interested in writing smart contracts which will one day be enveloped by Ethereum's alternative data infrastructure. Ethereum currently uses the complex Merkle Patricia Trie, however Vitalik has recently demonstrated https://github.com/ethereum/research/tree/master/trie_research/bintrie2[via code] that the Sparse Merkle Trie has the potential to surpass Ethereum's current data infrastructure in efficiency and simplicity as well as storage and bandwidth.
